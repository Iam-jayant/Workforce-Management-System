/**
 * Firestore collection schemas and configuration
 */

export const COLLECTIONS = {
  JOBS: 'jobs',
  USERS: 'users',
  TIMESHEETS: 'timesheets',
  JOB_ASSIGNMENTS: 'job_assignments',
  JOB_HISTORY: 'job_history',
  CUSTOMERS: 'customers',
  EQUIPMENT: 'equipment',
  SKILLS: 'skills',
  PERFORMANCE_METRICS: 'performance_metrics'
} as const;

export const SUBCOLLECTIONS = {
  JOB_UPDATES: 'updates',
  JOB_PHOTOS: 'photos',
  JOB_NOTES: 'notes',
  TIMESHEET_ENTRIES: 'entries'
} as const;

/**
 * Firestore document schemas for validation
 */
export interface FirestoreJobDocument {
  // Basic job information
  title: string;
  description: string;
  type: string;
  status: string;
  priority: string;
  
  // Customer and location
  customer: {
    id: string;
    name: string;
    email?: string;
    phone: string;
    alternatePhone?: string;
    address: {
      address: string;
      latitude: number;
      longitude: number;
      city: string;
      state: string;
      zipCode: string;
      landmark?: string;
      accessInstructions?: string;
    };
    notes?: string;
  };
  
  location: {
    address: string;
    latitude: number;
    longitude: number;
    city: string;
    state: string;
    zipCode: string;
    landmark?: string;
    accessInstructions?: string;
  };
  
  // Assignment
  assignedTechnicianId?: string;
  assignedBy?: string;
  assignedAt?: FirebaseFirestore.Timestamp;
  
  // Scheduling
  scheduledDate: FirebaseFirestore.Timestamp;
  scheduledTimeSlot: {
    start: string;
    end: string;
  };
  estimatedDuration: number;
  
  // Requirements
  requirements: {
    skills: string[];
    equipment: Array<{
      id: string;
      name: string;
      model: string;
      serialNumber?: string;
      quantity: number;
      description?: string;
    }>;
    estimatedDuration: number;
    tools: string[];
    specialInstructions?: string;
  };
  
  // Progress tracking
  startedAt?: FirebaseFirestore.Timestamp;
  completedAt?: FirebaseFirestore.Timestamp;
  actualDuration?: number;
  
  // Notes and updates
  notes: string[];
  internalNotes: string[];
  
  // Metadata
  createdBy: string;
  createdAt: FirebaseFirestore.Timestamp;
  updatedAt: FirebaseFirestore.Timestamp;
  
  // Completion details
  completionNotes?: string;
  customerSignature?: string;
  photos?: string[];
  workSummary?: string;
  
  // Search and indexing fields
  searchKeywords: string[];
  locationGeoHash?: string;
}

export interface FirestoreUserDocument {
  email: string;
  name: string;
  role: 'admin' | 'manager' | 'technician';
  phoneNumber: string;
  skills: string[];
  isActive: boolean;
  
  // Profile information
  profilePhoto?: string;
  employeeId?: string;
  department?: string;
  supervisor?: string;
  
  // Location and availability
  currentLocation?: {
    latitude: number;
    longitude: number;
    timestamp: FirebaseFirestore.Timestamp;
    accuracy: number;
  };
  
  workingHours: {
    start: string;
    end: string;
    timezone: string;
  };
  
  // Performance metrics
  performanceMetrics?: {
    jobsCompleted: number;
    averageRating: number;
    onTimePercentage: number;
    lastUpdated: FirebaseFirestore.Timestamp;
  };
  
  // Metadata
  createdAt: FirebaseFirestore.Timestamp;
  updatedAt: FirebaseFirestore.Timestamp;
  lastLoginAt?: FirebaseFirestore.Timestamp;
}

export interface FirestoreTimesheetDocument {
  technicianId: string;
  date: FirebaseFirestore.Timestamp;
  
  entries: Array<{
    jobId: string;
    checkInTime: FirebaseFirestore.Timestamp;
    checkOutTime: FirebaseFirestore.Timestamp;
    location: string;
    coordinates: {
      latitude: number;
      longitude: number;
    };
    hoursWorked: number;
    mileage: number;
    notes?: string;
    isAutoGenerated: boolean;
  }>;
  
  totalHours: number;
  totalMileage: number;
  regularHours: number;
  overtimeHours: number;
  
  status: 'draft' | 'submitted' | 'approved' | 'rejected';
  approvedBy?: string;
  approvedAt?: FirebaseFirestore.Timestamp;
  rejectionReason?: string;
  
  // Metadata
  createdAt: FirebaseFirestore.Timestamp;
  updatedAt: FirebaseFirestore.Timestamp;
}

export interface FirestoreJobAssignmentDocument {
  jobId: string;
  technicianId: string;
  assignedBy: string;
  assignedAt: FirebaseFirestore.Timestamp;
  notes?: string;
  
  // Assignment context
  assignmentReason: 'proximity' | 'skills' | 'availability' | 'manual' | 'emergency';
  distanceFromTechnician?: number;
  estimatedTravelTime?: number;
  
  // Status tracking
  acceptedAt?: FirebaseFirestore.Timestamp;
  rejectedAt?: FirebaseFirestore.Timestamp;
  rejectionReason?: string;
}

/**
 * Firestore indexes configuration
 */
export const FIRESTORE_INDEXES = [
  // Jobs collection indexes
  {
    collection: COLLECTIONS.JOBS,
    fields: [
      { field: 'status', order: 'asc' },
      { field: 'createdAt', order: 'desc' }
    ]
  },
  {
    collection: COLLECTIONS.JOBS,
    fields: [
      { field: 'assignedTechnicianId', order: 'asc' },
      { field: 'scheduledDate', order: 'asc' }
    ]
  },
  {
    collection: COLLECTIONS.JOBS,
    fields: [
      { field: 'priority', order: 'desc' },
      { field: 'scheduledDate', order: 'asc' }
    ]
  },
  {
    collection: COLLECTIONS.JOBS,
    fields: [
      { field: 'type', order: 'asc' },
      { field: 'status', order: 'asc' },
      { field: 'createdAt', order: 'desc' }
    ]
  },
  
  // Users collection indexes
  {
    collection: COLLECTIONS.USERS,
    fields: [
      { field: 'role', order: 'asc' },
      { field: 'isActive', order: 'asc' }
    ]
  },
  {
    collection: COLLECTIONS.USERS,
    fields: [
      { field: 'skills', order: 'asc' },
      { field: 'isActive', order: 'asc' }
    ]
  },
  
  // Timesheets collection indexes
  {
    collection: COLLECTIONS.TIMESHEETS,
    fields: [
      { field: 'technicianId', order: 'asc' },
      { field: 'date', order: 'desc' }
    ]
  },
  {
    collection: COLLECTIONS.TIMESHEETS,
    fields: [
      { field: 'status', order: 'asc' },
      { field: 'date', order: 'desc' }
    ]
  },
  
  // Job assignments collection indexes
  {
    collection: COLLECTIONS.JOB_ASSIGNMENTS,
    fields: [
      { field: 'technicianId', order: 'asc' },
      { field: 'assignedAt', order: 'desc' }
    ]
  },
  {
    collection: COLLECTIONS.JOB_ASSIGNMENTS,
    fields: [
      { field: 'jobId', order: 'asc' },
      { field: 'assignedAt', order: 'desc' }
    ]
  }
];

/**
 * Firestore security rules (for reference)
 */
export const FIRESTORE_SECURITY_RULES = `
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Jobs collection
    match /jobs/{jobId} {
      allow read: if isAuthenticated() && (
        isAdmin() || 
        isManager() || 
        (isTechnician() && resource.data.assignedTechnicianId == request.auth.uid)
      );
      
      allow create: if isAuthenticated() && (isAdmin() || isManager()) &&
        validateJobData(request.resource.data);
      
      allow update: if isAuthenticated() && (
        (isAdmin() || isManager()) ||
        (isTechnician() && resource.data.assignedTechnicianId == request.auth.uid &&
         onlyUpdatingAllowedFields())
      ) && validateJobData(request.resource.data);
      
      allow delete: if isAuthenticated() && (isAdmin() || isManager());
    }
    
    // Users collection
    match /users/{userId} {
      allow read: if isAuthenticated() && (
        isAdmin() || 
        isManager() || 
        userId == request.auth.uid
      );
      
      allow create: if isAuthenticated() && isAdmin() &&
        validateUserData(request.resource.data);
      
      allow update: if isAuthenticated() && (
        isAdmin() || 
        (userId == request.auth.uid && onlyUpdatingOwnProfile())
      ) && validateUserData(request.resource.data);
      
      allow delete: if isAuthenticated() && isAdmin();
    }
    
    // Timesheets collection
    match /timesheets/{timesheetId} {
      allow read: if isAuthenticated() && (
        isAdmin() || 
        isManager() || 
        (isTechnician() && resource.data.technicianId == request.auth.uid)
      );
      
      allow create: if isAuthenticated() && 
        validateTimesheetData(request.resource.data);
      
      allow update: if isAuthenticated() && (
        (isAdmin() || isManager()) ||
        (isTechnician() && resource.data.technicianId == request.auth.uid &&
         resource.data.status == 'draft')
      ) && validateTimesheetData(request.resource.data);
      
      allow delete: if isAuthenticated() && (isAdmin() || isManager());
    }
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isAdmin() {
      return request.auth.token.role == 'admin';
    }
    
    function isManager() {
      return request.auth.token.role == 'manager';
    }
    
    function isTechnician() {
      return request.auth.token.role == 'technician';
    }
    
    function validateJobData(data) {
      return data.keys().hasAll(['title', 'description', 'type', 'status', 'priority', 'customer', 'location', 'scheduledDate', 'requirements', 'createdBy']) &&
        data.title is string && data.title.size() > 0 &&
        data.description is string && data.description.size() > 0 &&
        data.type in ['installation', 'repair', 'maintenance', 'inspection', 'upgrade', 'emergency'] &&
        data.status in ['pending', 'assigned', 'in_progress', 'completed', 'cancelled', 'on_hold'] &&
        data.priority in ['low', 'medium', 'high', 'urgent'];
    }
    
    function validateUserData(data) {
      return data.keys().hasAll(['email', 'name', 'role', 'phoneNumber', 'skills', 'isActive']) &&
        data.email is string && data.email.matches('.*@.*\\..*') &&
        data.name is string && data.name.size() > 0 &&
        data.role in ['admin', 'manager', 'technician'] &&
        data.phoneNumber is string &&
        data.skills is list &&
        data.isActive is bool;
    }
    
    function validateTimesheetData(data) {
      return data.keys().hasAll(['technicianId', 'date', 'entries', 'totalHours', 'status']) &&
        data.technicianId is string &&
        data.date is timestamp &&
        data.entries is list &&
        data.totalHours is number && data.totalHours >= 0 &&
        data.status in ['draft', 'submitted', 'approved', 'rejected'];
    }
    
    function onlyUpdatingAllowedFields() {
      return request.resource.data.diff(resource.data).affectedKeys()
        .hasOnly(['status', 'startedAt', 'completedAt', 'actualDuration', 'notes', 'completionNotes', 'photos', 'workSummary', 'updatedAt']);
    }
    
    function onlyUpdatingOwnProfile() {
      return request.resource.data.diff(resource.data).affectedKeys()
        .hasOnly(['name', 'phoneNumber', 'profilePhoto', 'currentLocation', 'updatedAt', 'lastLoginAt']);
    }
  }
}
`;